mod cli;
mod mirrors;

use arch_mirrors_rs::{Mirror, Status};
use chrono::{DateTime, TimeDelta, Utc};
pub use cli::{Cli, Filters};
use comfy_table::{Cell, CellAlignment, Table, modifiers::UTF8_ROUND_CORNERS, presets::UTF8_FULL};
use mirrors::{count_countries, get_cache_file, get_mirror_status};
use std::fs::File;
use std::io::{self, Write};

struct Metadata<'a> {
    command: String,
    when: DateTime<Utc>,
    origin: &'a str,
    retrieved: DateTime<Utc>,
    last_check: DateTime<Utc>,
}

pub async fn run(options: &Cli) {
    let cache_file = get_cache_file(None);
    let when = Utc::now();
    let status = match get_mirror_status(10, 10, &options.url, &cache_file).await {
        Ok(status) => status,
        Err(err) => {
            eprintln!("error: {err}");
            return;
        }
    };

    if options.list_countries {
        list_countries(&status);
        return;
    }

    let mirrors = filter_status(&options.run.filters, &status);

    let metadata = Metadata {
        command: "reflector".to_string(),
        when,
        origin: options.url.as_ref(),
        retrieved: when,
        last_check: when,
    };

    let result = if let Some(path) = &options.run.save {
        File::create(path).and_then(move |file| format_output(&metadata, mirrors, file))
    } else {
        format_output(&metadata, mirrors, io::stdout())
    };

    if let Err(err) = result {
        eprintln!("error: {err}");
    }
}

fn format_output<'a>(
    metadata: &Metadata,
    mirrors: impl Iterator<Item = &'a Mirror>,
    mut out: impl Write,
) -> io::Result<()> {
    writeln!(
        out,
        "################################################################################\n\
                 ################# Arch Linux mirrorlist generated by Reflector #################\n\
                 ################################################################################\n"
    )?;
    writeln!(
        out,
        "# With:       {}\n# When:       {}\n# From:       {}\n# Retrieved:  {}\n# Last Check: {}\n",
        metadata.command, metadata.when, metadata.origin, metadata.retrieved, metadata.last_check
    )?;
    for mirror in mirrors {
        writeln!(out, "Server = {}$repo/os/$arch", mirror.url)?;
    }
    Ok(())
}

#[allow(clippy::cast_sign_loss)]
#[allow(clippy::cast_possible_truncation)]
pub(crate) fn filter_status<'a>(
    filters: &'a Filters,
    status: &'a Status,
) -> impl Iterator<Item = &'a Mirror> {
    let now = Utc::now();
    let min_completion_pct = f64::from(filters.completion_percent) / 100.0;
    status.urls.iter().filter(move |mirror| {
        if let Some(last_sync) = mirror.last_sync {
            // Filter by age. The age is given in hours and converted to seconds. Servers
            // with a last refresh older than the age are omitted.
            if let Some(age) = filters.age {
                let max_age =
                    TimeDelta::new((age * 3600.0) as i64, 0).expect("invalid age parameter");
                if age > 0.0 && last_sync + max_age < now {
                    return false;
                }
            }
        } else {
            // Filter unsynced mirrors.
            return false;
        }

        // Filter by completion "percent" [0-1].
        if let Some(completion_pct) = mirror.completion_pct {
            if completion_pct < min_completion_pct {
                return false;
            }
        }

        if !filters.country.is_empty()
            && !filters.country.contains(&mirror.country)
            && !filters.country.contains(&mirror.country_code)
        {
            return false;
        }

        // Filter by protocols.
        if !filters.protocol.is_empty() && !filters.protocol.contains(&mirror.protocol) {
            return false;
        }

        // Filter by delay. The delay is given as a float of hours and must be
        // converted to seconds.
        if let Some(delay) = filters.delay {
            let max_delay = (delay * 3600.0) as u32;
            if let Some(mirror_delay) = mirror.delay {
                if mirror_delay > max_delay {
                    return false;
                }
            } else {
                return false;
            }
        }

        // Filter by ISO hosing.
        if filters.isos && !mirror.isos {
            return false;
        }

        // Filter by IPv4 support.
        if filters.ipv4 && !mirror.ipv4 {
            return false;
        }

        // Filter by IPv6 support.
        if filters.ipv6 && !mirror.ipv6 {
            return false;
        }

        true
    })
}

pub fn list_countries(status: &Status) {
    let counts = count_countries(&status.urls);
    let mut sorted = vec![];
    for (country, count) in counts {
        sorted.push((country, count));
    }
    sorted.sort_by(|c1, c2| c1.0.code.cmp(c2.0.code));

    let mut table = Table::new();
    table
        .load_preset(UTF8_FULL)
        .apply_modifier(UTF8_ROUND_CORNERS)
        .set_header(vec!["Country", "Code", "Count"]);

    for (country, count) in sorted {
        table.add_row(vec![
            Cell::new(country.country.to_string()),
            Cell::new(country.code.to_string()),
            Cell::new(count.to_string()).set_alignment(CellAlignment::Right),
        ]);
    }
    println!("{table}");
}
